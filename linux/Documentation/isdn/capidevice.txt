                            CAPI Device Interface
                            ~~~~~~~~~~~~~~~~~~~~~

                              Frank A. Uepping
                                 2004-10-29


The capicore provides an infrastructure for the communication between CAPI
drivers and CAPI applications.  This document describes the interface at the
driver layer.  See capidevice.h and capiappl.h in include/linux/isdn/ for the
declarations of the various functions and types used.

The service that drivers provide to the capicore is the sending and receiving
of CAPI messages.  Consequently, the driver interface is quite straightforward,
comprising the following components:

* A generic device structure.

* Allocating and reference counting of devices.

* Registration and release of devices.

* Registration and release of applications.

* Message exchange.


Generic CAPI Device Structure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Devices are represented to the capicore via objects of the generic capi_device
structure.  This structure forms the basis of communication between the capicore
and drivers.

Drivers own the following fields in the generic capi_device structure:

* product -- the product name of the device.

* manufacturer, serial, version and profile -- the CAPI specific fields.
  See the CAPI standard for more information about these fields.

* drv -- pointer to the capi_driver operations structure.
  All devices of a driver share this structure.

* class_dev.dev -- pointer to the associated generic device object.
  This field may be NULL, if there is no such object (e.g. virtual CAPI device).
  The driver should use capi_device_set_dev() and capi_device_get_dev() in order
  to access this field.

* class_dev.class_data -- pointer free to use by the driver.
  Usually, this field points to the driver specific device structure.  The
  driver should use capi_device_set_devdata() and capi_device_get_devdata() in
  order to access this field.

* stats -- structure containing fields for statistics purposes.
  The driver is responsible for updating the statistics and may freely use the
  stats.lock field; the capicore will never touch that lock.
  The capicore will pre-initialize stats for the driver.

The capi_device object must be created by the driver via capi_device_alloc(),
and must exists from the time that capi_device_register() is called until after
the call to capi_device_unregister() returns.


Allocating and Reference Counting of CAPI Devices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
An object of the capi_device structure is reference counted.  As such it has
to be dynamically allocated by the driver, and will be freed when the last
reference has been released.

The capicore provides these functions to drivers:

* capi_device_alloc() -- allocate a generic capi_device structure.
  The reference counter is initialized to one.

* capi_device_get() -- acquire a reference to the capi_device structure.
  The reference counter is incremented by one.

* capi_device_put() -- release a reference to the capi_device structure.
  The reference counter is decremented by one, and the object will be freed
  if the reference counter drops to zero.

While capi_device_alloc() blocks, capi_device_get() and capi_device_put()
do not.


Registration and Release of CAPI Devices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In order for the capicore to become aware of CAPI devices, the generic
capi_device objects need to be registered with the capicore.  At the time when
a CAPI device wants to leave, it needs to be released from the capicore.

The capicore provides these functions to drivers for that purpose:

* capi_device_register() -- register a device with the capicore.
  After this call returns all existing applications have been registered with
  the device.

* capi_device_unregister() -- unregister a device from the capicore.
  After this call returns, the capicore guarantees that no thread will be
  executing in a call from the capicore to that driver's functions
  capi_register(), capi_release() or capi_put_message(), and the capicore
  will not call either of those functions subsequently.  Afterwards the
  driver should release the device structure via capi_device_put().

Both functions are blocking, and so they have to be called from process
context.


Registration and Release of CAPI Applications
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In order for devices to become aware of an application, the application needs
to be registered with the devices.  At the time when the application leaves
the system, it will be released from the devices registered with.

The driver has to provide two functions via the capi_driver operations
structure for that purpose:

* capi_register() -- register an application with the device.
  The driver may refuse to register the application by returning an
  appropriate value.

* capi_release() -- release an application from the device.
  After return from this call, the driver must ensure that no thread will be
  executing in capi_appl_enqueue_message(), capi_appl_signal() or
  capi_appl_signal_error() for that application, and the driver must not
  call either of those functions subsequently.

Both functions must be thread safe and get called from process context (so they
are allowed to block).


CAPI Message Exchange
~~~~~~~~~~~~~~~~~~~~~
The service that drivers provide to the capicore is the sending and receiving
of messages.  Messages issued by drivers must be valid as described by the CAPI
standard, and must be in conformance with the CAPI state machines.

The capicore provides these functions to drivers:

* capi_appl_enqueue_message() -- add a message to the tail of the application's
  message queue.  The queue has unbounded capacity, and the driver has to adhere
  to the CAPI window protocol in order to prevent the queue from growing
  immensely.

* capi_appl_signal() -- signal to the application the arrival of messages or
  the clearance of a busy or queue-full condition.

* capi_appl_signal_error() -- signal a fatal message exchange error to the
  application.  The signaled error is permanent and will force the application
  to release.  The only errors which make sense here are:
  CAPINFO_0X11_QUEUEOVERFLOW and CAPINFO_0X11_OSRESERR.

These functions will never block, and it is allowed to call them from hardware
interrupt context.

In order for a driver to receive messages from the capicore it has to provide
a function via the capi_driver operations structure.

* capi_put_message() -- receive a message from the capicore.
  The message is at least 12 bytes long, no other guarantees are made.
  The driver may reject the message for flow-control reasons (via returning
  CAPINFO_0X11_QUEUEFULL or CAPINFO_0X11_BUSY), but then, it must later call
  capi_appl_signal() when the condition has been cleared.
  This function must be thread safe and may not to block.
