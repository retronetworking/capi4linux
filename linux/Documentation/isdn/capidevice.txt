                            CAPI Device Interface
                            ~~~~~~~~~~~~~~~~~~~~~

                               Frank A. Uepping
                                 13 Aug 2004

The capicore provides an infrastructure for the communication between CAPI
drivers and CAPI applications.  This document describes the interface at the
driver layer.  See capidevice.h and capiappl.h in include/linux/isnd/ for the
declarations of the various functions and types used.

The service that drivers provide to the capicore is the sending and receiving
of CAPI messages.  Consequently, the driver interface is quite straightforward,
comprising the following components:

* A generic device structure.

* Allocating and reference counting of devices.

* Registration and release of devices.

* Registration and release of applications.

* Message exchange.


Generic CAPI Device Structure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Devices are represented to the capicore via objects of the generic capi_device
structure.  This structure forms the basis of communication between the capicore
and drivers.

Drivers own the following fields in the generic capi_device structure:

* manufacturer, serial, version and profile -- the CAPI specific fields.

* drv -- pointer to the capi_driver structure.
  All devices of a driver share this structure.

* class_dev.dev -- pointer to the associated generic device object.
  This field may be NULL, if there is no such object.  The driver should use
  capi_device_set_dev() and capi_device_get_dev() to access this field.

* class_dev.class_data -- pointer free to use by the driver.
  Usually, this field points to the driver specific device structure.  The
  driver should use capi_device_set_devdata() and capi_device_get_devdata() to
  access this field.

* stats -- structure containing fields for statistics purposes.
  The driver is responsible for updating the statistics, and may freely use the
  stats.lock field if necessary -- the capicore will never touch that lock, and
  will initialize stats for the driver.

The capi_device object must exists from the time that capi_device_register()
is called until after the call to capi_device_unregister() returns.


Allocating and Reference Counting of CAPI Devices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
An object of the capi_device structure is reference counted.  As such it has
to be dynamically allocated by the driver, and will be freed when the last
reference has been released.

The capicore provides these functions to drivers:

* capi_device_alloc() -- allocate a generic capi_device structure.
  The reference counter is initialized to one.  This call may block.

* capi_device_get() -- acquire a reference to the capi_device structure.
  The reference counter is incremented by one.

* capi_device_put() -- release a reference to the capi_device structure.
  The reference counter is decremented by one, and the object will be freed
  if the reference counter drops to zero.


Registration and Release of CAPI Devices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Devices are represented to the capicore via objects of the generic capi_device
structure.  A proper initialized capi_device object is ready for registration
by the driver.

The capicore provides these functions to drivers:

* capi_device_register() -- register a device with the capicore.

* capi_device_unregister() -- unregister a device from the capicore.
  After this call returns, the capicore guarantees that no thread will be
  executing in a call from the capicore to that driver's functions
  capi_register(), capi_release() or capi_put_message(), and the capicore
  will not call either of those functions subsequently.

Both functions may block, and so they have to be called from process context.


Registration and Release of CAPI Applications
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In order to make devices aware of an application, the application needs to
be registered with the devices.  At the time when the application leaves the
system, it will be released from the devices registered with.

The driver has to provide two functions via the capi_driver structure:

* capi_register() -- register an application with the device.

* capi_release() -- release an application from the device.
  The driver may not call any of capi_appl_enqueue_message(), capi_appl_signal()
  or capi_appl_signal_error() after this call has returned.

Both functions may get called concurrently and may block, but may not be slow
(i.e. blocking indefinitely).


CAPI Message Exchange
~~~~~~~~~~~~~~~~~~~~~
The service that drivers provide to the capicore is the sending and receiving
of messages.  Messages issued by drivers must be valid as described by the CAPI
standard, and must be in conformance with the CAPI state machines.  Messages
issued by the capicore are at least 12 bytes long -- no other guarantees are
made.

The capicore provides these functions to drivers:

* capi_appl_enqueue_message() -- add a message to the tail of the application's
  message queue.  The queue has unbounded capacity, and the driver has to adhere
  to the CAPI window protocol in order to prevent the queue from growing
  immensely.

* capi_appl_signal() -- request the application to fetch messages from its
  queue.  A driver should enqueue as many messages as possible before calling
  that function.

* capi_appl_signal_error() -- signal a fatal message exchange error to the
  application.  The signaled error is permanent and will force the application
  to release.

Those functions will never block, and it is safe to call them from interrupt
context.

Drivers have to provide a function via the capi_driver structure in order to
receive messages from the capicore:

* capi_put_message() -- receive a message from the capicore.
  This function may get called concurrently and may block, but may not be slow
  (i.e. blocking indefinitely).
